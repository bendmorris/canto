
[TOC]

# Configuration

This section covers Canto's basics features and how to use filters, sorts, tags, 
and the other pre-written goodies that can be found in `canto.extra`.  The 
actual writing of custom content is covered in later sections.

### Test

Blah

## Adding feeds

<div class="section">

### `add()`

`add` is the basic building block of Canto's config. As the name suggests, it
adds a feed to the config. Ninety-nine percent of the time, a call like this 
will get the job done:

    :::python
    add("http://someurl")

You can also tweak some other settings having to do with fetching the feed. The
`rate` and `keep` variables effect the rate at which the feed is fetched from
the server and `keep` determines how many items should be kept. The following
line will update a feed every 30 minutes and keep up to a 100 items.

    :::python
    add("http://someurl", rate=30, keep=100)

> **NOTE**: "keep" will be silently ignored if it's below the number of items
> in the feed. In fact, by default `keep = 0`. This behavior differs from 
> 0.6.x.

> The default `rate` is 5 for fetching from the server every five minutes.

### Password protected feeds

If the feed is behind browser authentication (i.e. when you try to reach it in a
browser it brings up a username/password box), you can specify those in the feed
definition too.

    :::python
    add("http://someprotectedurl", username="myuser", password="mypass")

> **NOTE**: In order to protect sensitive information in your config, it's
> standard practice to `chmod 600 ~/.canto/conf` so that other users can't 
> read your password even if they can read your home directory. However, 
> Canto will not enforce these permissions as some other programs.

There are a few other options for `add`, but these are more logically covered
elsewhere.

### "Sourcing" other files

Canto supports adding feeds from other file formats. This can be useful when
trying to keep URLs synced between readers. Canto can source OPML files at
runtime simply by giving a path to the OPML file.

    :::python
    source_opml("/home/myuser/feeds.opml")

Canto can also source plain lists of URLs, delimited by newlines.

    :::python
    source_urls("/home/myuser/urls")

Feeds that are sourced are added with the equivalent of a basic `add` call
with a URL. If you want to add other attributes to feeds that have been added
this way, then you can use `change_feed` that takes the same arguments as 
`add` does.

### Tweaking defaults

At some point you may want to change the `rate` and `keep` parameters for a 
large quantity of feeds and do so simultaneously.  Using `default_rate` and 
`default_keep` you can set those parameters for **every feed following 
the call**. Because this change only affects feeds that are added after the 
call, it can be used to set 'keep' and 'rate' variables for batches of feeds, 
rather than all feeds.  If you want the 'keep' and 'rate' variables to affect 
all feed behavior globally, set the defaults before you define your feeds.

> **NOTE**: To reiterate from above, `rate` is in minutes and `keep` will 
> ignore any number lower than the number of items in the feed's source.

The following is a good application of using the default calls:

    :::python

    default_rate(30)    # News feeds 
    add("http://news1")
    add("http://news2")
    ...

    default_rate(120)   # Slow blog feeds
    add("http://blog1")
    add("http://blog2")
    ...

    default_rate(1)     # Quick feed
    default_keep(100)   # Lots of items could be missed
    add("http://quick1")
    add("http://quick2")
    ...

If you choose not to change settings, rate is set to five minutes (5) and keep 
is set to 0, which indicates that all the items in the feed source should be 
kept.

</div>

## Browsing

<div class="section">

Canto supports using external programs to open the content found in a feed item.
Typically, you just want to set a `link_handler` to your favorite browser.

    :::python
    link_handler("firefox \"%u\"")

This will use firefox as your browser. The `\"%u\"` will be replaced with the
URL. Users that want to use a text based browser like
[elinks](http://elink.or.cz), have to tell Canto to relinquish the terminal
while you use it, like so:

    :::python
    link_handler("elinks \"%u\"", text=True)

If you find yourself bouncing between the Linux console and an X terminal,
you can use a bit of logic to automatically set the browser based on the
`TERM` environmental variable.

    :::python
    import os
    if os.getenv("TERM") == "linux":
        link_handler("elinks \"%u\"", text=True)    # Text-only
    else:
        link_handler("firefox \"%u\"")              # X terminal

### Non-HTML content

Links to PDFs and other content you'd rather view in a program other than
your browser (like enclosures) can be setup by using `link_handler` with an
extension. For example, to open and .mp3 in a podcast:

    :::python
    link_handler("mplayer -someoptions \"%u\"", ext="mp3")

Fortunately, mplayer can stream from the web by default. Some applications
require the content to be fetched before hand. This requirement can be handled
using the `fetch` parameter. For example, to open a .pdf in evince that doesn't
support opening from the internet directly you can write:

    :::python
    link_handler("evince \"%u\"", ext="pdf", fetch=True)

Canto will then fetch the content into `/tmp` and run the associated program.

### Images

Images are handled similarly to links with the `image_handler` call. It takes
the same arguments as `link_handler`. A good example:

    :::python
    image_handler("fbv \"%u\"", text=True, fetch=True)

This will use `fbv` to view an image in a text console.

> NOTE: Image links are denoted by the color blue in the reader

</div>

# Using Advanced Features

Canto is extremely powerful due to its internal use of the Python
interpreter for all of its configuration requirements. The details of writing 
extension content is covered elsewhere, but there is a lot of good information
included with the source.

## Importing canto.extra

<div class="section">

In order to use extra content it must be imported in the usual pythonic way, as 
in:

    :::python
    from canto.extra import *

A call to import canto.extra will make all of the goodies packaged with Canto 
available to your config.

</div>

## Keybinds

<div class="section">

### Specifying keys

The first step to define your own keybinds is to learn how to specify which key
you're binding to. Typically, it's very easy to rebind keys.

    :::python
    keys['a'] = ...
    reader_keys['a'] = ...

Any visible non-newline character can be used directly. Whitespace characters
(including newline) can be embedded with their typical escape (i.e. \t for tab,
\n for newline, etc.).

    :::python
    keys['\n'] = ...    # Enter
    keys['\t'] = ...    # Tab
    keys[' '] = ...     # Space
    keys['  '] = ...    # Tab

Any invisible characters, like function keys, arrow keys, etc. can be used by
their ncurses name. On the man page for `getch()`, a list of all possible
names is available. Here's an [online copy]
(http://www.mkssoftware.com/docs/man3/curs_getch.3.asp).  Typically definitions 
using these keys look like this:

    :::python
    keys['KEY_F1'] = ...
    keys['KEY_LEFT'] = ...

To specify Control or Alt key combinations, you can use "C-" for control and
"M-" (meta) for Alt.

    :::python
    keys['C-a'] = ...   # Ctrl+A
    keys['M-a'] = ...   # Alt+A
    keys['C-M-a'] = ... # Ctrl+Alt+A

### Default binds

The following keybinds are typically available to the user. They will be used 
in the examples below.


#### Main view

<table>
<tr>
<td>Name</td>
<td>Function</td>
<td>Default Binding</td>
</tr>
<tr>
<td><pre>help</pre></td>
<td>Shows the man page (has all of these bindings listed).</td>
<td><pre>h</pre></td>
</tr>
<tr>
<td><pre>next_item</pre></td>
<td>Move to the next item.</td>
<td><pre>KEY_DOWN / j</pre></td>
</tr>
<tr>
<td><pre>prev_item</pre></td>
<td>Move to the previous item.</td>
<td><pre>KEY_UP / k</pre></td>
</tr>
<tr>
<td><pre>next_tag</pre></td>
<td>Move to the next feed/group of items</td>
<td><pre>KEY_NPAGE</pre></td>
</tr>
<tr>
<td><pre>prev_tag</pre></td>
<td>Move to the previous feed/group of items.</td>
<td><pre>KEY_PPAGE</pre></td>
</tr>
<tr>
<td><pre>just_read</pre></td>
<td>Mark current story read and nothing else.</td>
<td><pre>KEY_RIGHT</pre></td>
</tr>
<tr>
<td><pre>just_unread</pre></td>
<td>Mark current story unread and nothing else.</td>
<td><pre>KEY_LEFT</pre></td>
</tr>
<tr>
<td><pre>goto</pre></td>
<td>Open the current story in your browser.</td>
<td><pre>g</pre></td>
</tr>
<tr>
<td><pre>inline_search</pre></td>
<td>Mark all stories matching a search.</td>
<td><pre>f</pre></td>
</tr>
<tr>
<td><pre>next_mark</pre></td>
<td>Go to the next marked story.</td>
<td><pre>n</pre></td>
</tr>
<tr>
<td><pre>prev_mark</pre></td>
<td>Go to the previous marked story.</td>
<td><pre>p</pre></td>
</tr>
<tr>
<td><pre>next_unread</pre></td>
<td>Go to the next unread story.</td>
<td><pre>.</pre></td>
</tr>
<tr>
<td><pre>prev_unread</pre></td>
<td>Go to the previous unread story.</td>
<td><pre>,</pre></td>
</tr>
<tr>
<td><pre>reader</pre></td>
<td>Open the reader.</td>
<td><pre>Space</pre></td>
</tr>
<tr>
<td><pre>toggle_collapse_tag</pre></td>
<td>Collapse/Show a feed/group of items.</td>
<td><pre>c</pre></td>
</tr>
<tr>
<td><pre>set_collapse_all</pre></td>
<td>Collapse on all feeds/groups.</td>
<td><pre>C</pre></td>
</tr>
<tr>
<td><pre>unset_collapse_all</pre></td>
<td>Uncollapse all feeds/groups.</td>
<td><pre>V</pre></td>
</tr>
<tr>
<td><pre>toggle_mark</pre></td>
<td>Mark/unmark an item.</td>
<td><pre>m</pre></td>
</tr>
<tr>
<td><pre>all_unmarked</pre></td>
<td>Unmark all items</td>
<td><pre>M</pre></td>
</tr>
<tr>
<td><pre>tag_read</pre></td>
<td>Set all stories in a feed/group read.</td>
<td><pre>r</pre></td>
</tr>
<tr>
<td><pre>all_read</pre></td>
<td>Set all stories read.</td>
<td><pre>R</pre></td>
</tr>
<tr>
<td><pre>tag_unread</pre></td>
<td>Set all stories in a feed/group unread.</td>
<td><pre>u</pre></td>
</tr>
<tr>
<td><pre>all_unread</pre></td>
<td>Set all stories unread.</td>
<td><pre>U</pre></td>
</tr>
<tr>
<td><pre>force_update</pre></td>
<td>Reread stories from disk.</td>
<td><pre>C-r</pre></td>
</tr>
<tr>
<td><pre>refresh</pre></td>
<td>Redraw the screen.</td>
<td><pre>C-l</pre></td>
</tr>
<tr>
<td><pre>quit</pre></td>
<td>Quit Canto.</td>
<td><pre>q</pre></td>
</tr>
<tr>
<td><pre>next_filter</pre></td>
<td>Apply next global filter.</td>
<td><pre>]</pre></td>
</tr>
<tr>
<td><pre>prev_filter</pre></td>
<td>Apply previous global filter</td>
<td><pre>]</pre></td>
</tr>
<tr>
<td><pre>next_tag_filter</pre></td>
<td>Apply next tag filter (from filters)</td>
<td><pre>}</pre></td>
</tr>
<tr>
<td><pre>prev_tag_filter</pre></td>
<td>Apply previous feed filter</td>
<td><pre>{</pre></td>
</tr>
<tr>
<td><pre>prev_tagset</pre></td>
<td>Show previous set of tags</td>
<td><pre>&lt;</pre></td>
</tr>
<tr>
<td><pre>next_tagset</pre></td>
<td>Show next set of tags</td>
<td><pre>&gt;</pre></td>
<tr>
<td><pre>goto_reltag</pre></td>
<td>Goto the <code>nth</code> visible tag (filter aware)</td>
<td><pre>;</pre></td>
</tr>
<tr>
<td><pre>goto_tag</pre></td>
<td>Goto the <code>nth</code> tag (filter unaware)</td>
<td><pre>:</pre></td>
</tr>
</table>

#### Reader view

<table>
<tr>
<td>Name</td>
<td>Function</td>
<td>Default Binding</td>
</tr>
<tr>
<td><pre>scroll_down</pre></td>
<td>Scrolls, if there's more text.</td>
<td><pre>KEY_DOWN / j</pre></td>
</tr>
<tr>
<td><pre>scroll_up</pre></td>
<td>Scroll up, if not at the top.</td>
<td><pre>KEY_UP / k</pre></td>
</tr>
<tr>
<td><pre>page_down</pre></td>
<td>Page down.</td>
<td><pre>KEY_NPAGE</pre></td>
</tr>
<tr>
<td><pre>page_up</pre></td>
<td>Page Up.</td>
<td><pre>KEY_PPAGE</pre></td>
</tr>
<tr>
<td><pre>["destroy","next_item","reader"]</pre></td>
<td>Goto the next story without closing the reader.</td>
<td><pre>n</pre></td>
</tr>
<tr>
<td><pre>["destroy","prev_item","reader"]</pre></td>
<td>Goto the previous story without closing the reader.</td>
<td><pre>p</pre></td>
</tr>
<tr>
<td><pre>goto</pre></td>
<td>Go to a specific link listed inside the item text.</td>
<td><pre>g</pre></td>
</tr>
<tr>
<td><pre>toggle_show_links</pre></td>
<td>Show/hide the list of links at the bottom of the reader.</td>
<td><pre>l</pre></td>
</tr>
<tr>
<td><pre>quit</pre></td>
<td>Quit</td>
<td><pre>space</pre></td>
</tr>
</table>

### Using default binds

Setting a new key for pre-existing functionality is easy to do using strings.
As you can see in the above table, the bind "help" brings up the help page. To
rebind this functionality to the F1 key (a typical DOS binding), you could 
simpy do

    :::python
    keys["KEY_F1"] = "help"

As you might expect, you can also override existing keys

    :::python
    keys[' '] = "next_item" # Overrides the default "reader" command

And you can unset a key all together

    :::python
    keys['q'] = None    # Unsets 'q'

### Macros

Canto allows you to queue up more than one action with a keybind. A simple list
can get the job done. For example, to create a keybind that will set an item as
read and move to the next list item (rather than using the right arrow followed
by the down arrow) we could set a macro like this

    :::python
    keys['j'] = ["just_read", "next_item"]

"just_read" sets the item as read and "next_item" moves to the next item.

More complicated macros can be created that can cover both main view and reader 
view keybinds. Take for example the default binding of "n" in reader view.

    :::python
    reader_keys = [ "destroy", "next_item", "reader" ]

This macro allows you to go to the next item without leaving the reader. When 
this macro executes three events happen:  "destroy" kills the reader, 
"next_item" makes the main interface go to the next item, and "reader" makes the
main interface re-open the reader.  All this work is done with one keystroke. 

Another common macro task is to open the reader and automatically open the link 
list.  This also can be achieved with this simple code

    :::python
    keys[' '] = ["reader", "toggle_show_links" ]

Using macros and keybinds, it's possible to get a maximum amount of work from a 
minimum number of keystrokes.

### Keybind goodies.

Rebinding some existing functionality to a different key or creating a simple 
macro will certainly make most users work faster and easier. 

Up until now, we've only used strings in the keybinds and macros. These strings
are shorthand for built-in functionality. However, in place of these strings, 
you can bind functions to keystrokes.  Doing so, adds a very powerful feature to 
Canto's interface.

Later in the document we'll cover `set_filter`, `set_tag_filter`, and
`set_tag_sort` which are all defined in `canto.extra`. For now, we'll cover some
more interesting and useful additions.

#### Searching

You can setup a keybind to search for your favorite terms using the `search`
keybind, which takes a keyword argument or a regex. This uses the internal
`inline_search` behavior and marks all items matching the search.

    :::python
    keys['1'] = search("Linux")
    keys['2'] = search(".*[Uu]buntu.*", regex=True)

You can also use `search_filter` which will prompt you interactively for a
keyword (or a regex if you prefix the string with "rgx:") and filter out all
unmatching items.

    :::python
    keys['/'] = search_filter

Once again, note that `search_filter` is **not** in quotes, it is not a string
because it's not a builtin keybind. `search_filter` is defined in `canto.extra`
and therefore is used as a function.

#### Copying (Yanking)

A neat function for putting a link on the X clipboard (for use in pasting into a
chat, a browser, etc.) can be used

    :::python
    keys['y'] = yank

> **NOTE**: Yank requires `xclip` to be installed and visible in your `PATH`. On
Debian based distros it's the `xclip` package, but on some it might be included
with a generic X11 application meta-package. If in doubt, do `which xclip` from
your shell.

#### Saving

The last neat little utility is `save` which writes a file (~/canto_out) with a
title and a link when called. This is designed as a template example for writing
a keybind, rather than a fully functional bind but it can be useful.

    :::python
    keys['s'] = save

</div>

## Filters

<div class="section">

Perhaps the most useful extra feature Canto provides is its powerful filter 
system. `canto.extra` provides a number of filters to use

<table>
<tr>
<td><pre>None</pre></td>
<td>Filter no items.</td>
</tr>
<tr>
<td><pre>show_unread</pre></td>
<td>Ignore all items that have been marked read</td>
</tr>
<tr>
<td><pre>show_marked</pre></td>
<td>Ignore all items that are unmarked</td>
</tr>
<tr>
<td><pre>only_with("string")</pre></td>
<td>Show only items that have "string" in the title</td>
</tr>
<tr>
<td><pre>only_without("string")</pre></td>
<td>Show only items that **don't** have "string" in the title</td>
</tr>
<tr>
<td><pre>all_of(filter1, filter2, ...)</pre></td>
<td>Show only items that pass all listed filters (binary and)</td>
</tr>
<tr>
<td><pre>any_of(filter1, filter2, ...)</pre></td>
<td> Show items that pass any of the listed filters (binary or).</td>
</tr>
</table>

Additionally, there is `with_tag_in`, which is covered in the tag section, 
specifically.

There are three ways to apply filters.

- **Global filters**. These apply regardless. Any items that you see in the
interface had to pass through this filter. Global filters are useful, for 
example, to filter items based upon a given state, as in`show_unread`.

- **Tag filters**. These filters only apply to specific tags (See the
tag section).

- **Feed filters**. These filters are applied when loading content from disk.
Items that don't pass this filter will never appear in the interface. Feed 
filters are useful when you want to ignore a whole set of items entirely, like 
news posts in webcomic feeds.


### Using Global Filters

Of the the three filters, global filters are arguably the most useful.For 
example, a global filter can be used to filter out items that have already been 
read. Accomplishing that is simple:

    :::python
    filters=[show_unread]

Setting the 'show unread' filter will remove all previously read feed items by 
default when Canto opens. If you  still want to have access to all items, you 
can add the `None` filter to the list:

    :::python
    filters=[show_unread, None]

With this filter in place, you can switch between `show_unread` and `None` using
`[` and `]`to cycle through the list.

If you're more comfortable using a keybind to choose your global filters,
then you can use `set_filter`. This allows you to set the global filter
regardless of whether it's in the `filters` list:

    :::python
    keys['1'] = set_filter(show_unread)
    keys['2'] = set_filter(show_marked)
    keys['3'] = set_filter(None)

This lets you use the 1, 2, and 3 keys to set your filters directly, without
needing to cycle through the list.

### Using Feed Filters

Most of the time, feed filters are only useful if you want to completely
ignore some easily filtered content in a feed. My favorite example is
ignoring all non-comic items in a webcomic feed. Take
[penny-arcade](http://penny-arcade.com)'s feed for example. Each item's
title is clearly marked with "Comic:" or "News:".

If I wanted just completely ignore non-comic items, I could modify the `add`
call for Penny Arcade to use the `only_with` filter:

    :::python
    add("http://feeds.penny-arcade.com/pa-mainsite", filter=only_with("Comic:"))

This filter will eliminate all items that don't have "Comic:" in the title. 
Other examples include filtering distro package feeds for only a certain type
of package (i.e. Gentoo, `only_with("sys-devel")`), or filtering porn torrents
from torrent site feeds (`only_without("XXX")`, provided the feed items are 
clearly marked).

</div>

## Tags

<div class="section">

A tag is an arbitrary set of stories. By default, Canto creates a single tag per
feed and if you never use any other tags, feeds and tags are analogous.

A tag allows you to filter, sort and otherwise customize how these groups of
items are displayed.

### Manipulating Default Tags

As mentioned above, each feed is given a tag by default. That tag's name is the
name specified in the feed's source. So for the reddit feed, the tag's title
(which is displayed at the top of the box of stories in the interface) is
"reddit.com: what's new online!". That title is a bit long, and we want to use
something a little more concise. So, to override the default tag, we can add
this to the config:

    :::python
    add("http://reddit.com/.rss", tags=["Reddit"])

This addition will cause the displayed name to change to "Reddit" from the 
longer "reddit.com: what's new online!".

### Adding Tags

Adding a tag to a feed is as simple as coming up with a name and adding it to
the tag list.

    :::python
    add("http://some-blog", tags=[None, "blogs"])
    add("http://some-other-blog", tags=[None, "blogs"])

> **NOTE**: `None` in the tag is shorthand for using the title included with the
> feed. If all tags are omitted, `tags=[None]` is implied.

This addition will define an implicit tag "blogs". After adding that tag, you 
can use < and > to switch between the default set of tags (i.e. one per feed) 
to the "blogs" tag.

Notice that when you switch to the "blogs" tags, the displayed content will be 
the stories in the first feed followed by the stories in the second feed. This 
display may not seem very useful if you're using implicit tags, but, when you 
add a sort to mix, the two feeds you can achieve some neat effects, like 
organizing all of your favorite blog posts from around the internet in 
chronological order.

### Using Tags as Folders

Typically, the above behavior, appending the items together by using a common 
tag is not what a user expects unless they're going to use a sort.  Usually, 
tags are used as folders names so that switching to "blogs" means showing all 
the feeds that have "blogs" in the tags.

This behavior is accomplished using the `with_tag_in` filter. Following the 
above example, we can emulate folders with global filters:

    
    :::python
    add("http://some-blog", tags=[None, "blogs"])
    add("http://some-other-blog", tags=[None, "blogs"])
    filters = [ None, with_tag_in("blogs") ]

With this snippet, using ']' to switch to the next global filter will cause 
Canto to display only the items in the two "blogs" feeds, but the items will 
still be organized by feed rather than displayed as an appended list of items.

You can also list multiple tags and use implicit default tags for use in
`with_tag_in`

    :::python
    add("http://rss.slashdot.org/slashdot/Slashdot") # Creates implicit "Slashdot" tag
    add("http:/.some-blog", tags=[None, "blogs"])
    filters = [ None, with_tag_in("Slashdot", "blogs") ]

Lastly, you can combine `with_tag_in` and other filters with `all_of`

    :::python
    filters = [ None, all_of(with_tag_in("blogs"), show_unread) ]

This combination will make your second global filter show you all of your blog 
feeds, but only their unread items.

### Adding Explicit Tags

So far we've only dealt with implicit tags that are either created by default or
by appending a string to the `tags` list. Such creations are only useful for 
using tags with < / > or in filters.

However, tags themselves can have attributes. You can make an explicit tag with
the `add_tag` function.

    :::python
    add("http://some-blog", tags=[None, "blogs"])
    add("http://some-other-blog", tags=[None, "blogs"])
    add_tag("blogs", ...parameters...)

These definitions can come before or after you use them in `add` calls.

### Tag Filters

Tag filters, as the name would suggest only apply to a specific tag. These 
filters  are useful if a filter would only make sense for a certain set of items
rather than globally.

Let's return to the webcomic example from the [feed filter](#using-feed-filters)
section. In that example, we wanted to entirely discard posts that were news
and only see comics. Using a tag filter, however, it's possible to keep all
items, but merely hide (rather than entirely discard) the other stories. This is
useful if you want to prioritize one set of stories over another. In this case,
we want to prioritize the comics, but make the news items available on request.

    :::python
    add("http://feeds.penny-arcade.com/pa-mainsite") # Implicitly creates "Penny Arcade" tag
    add_tag("Penny Arcade", filters=[only_with("Comic:"), only_with("News:")])

This example makes the "Penny Arcade" tag explicit and sets up two tag filters.
Now when you've selected the Penny Arcade feed, you can use { and } to switch
between the tag filters and show comics or news. Alternatively, a similar effect
could be achieved by using `only_without("Comic:")` as the second filter, which
would allow all items not shown in the first filter, not necessarily just items
with "News:" in them.

Using these tag filters, you can essentially turn one tag or feed into multiple
overlapping tags and cycle through them.

> **NOTE**: Tag filters are always overridden by global filters. If your global
filter is `show_unread`, even if your tag filter is `None`, you won't see any
read items.

Like global filters, tag filters can be set by default.

    :::python
    default_tag_filters([show_unread])

Similar to `default_rate` and `default_keep`, these defaults are applied as
**explicit** tags are created. Any tags created with `add_tag` will inherit the
default tag filters from the call immediately before
the `add_tag` (or `[None]` if it hasn't been called at all). Implicit tags
(i.e. not created with `add_tag`) are made explicit after the rest of the
configuration is done, so they will inherit the defaults from the last call to
`default_tag_filters` made in the config.

Just like global filters, tag filters can be set directly via keybind

    :::python
    keys['u'] = set_tag_filter(show_unread)

This keybind will set the current tag's filter to `show_unread`.

> **NOTE** : Unlike global filters, tag filters will *never* make a tag fully
disappear since there would be no easy way to change the tag filter back to one
with items in it.

### Sorts

Another benefit of making explicit tags is the ability to sort items in varied 
ways. `canto.extra` defines some default sorts to use.

<table>
<tr>
<td><pre>None</pre></td>
<td>Use the ordering specified in the feed.</td>
</tr>
<tr>
<td><pre>by_date</pre></td>
<td>Order by the time the items are parsed.</td>
</tr>
<tr>
<td><pre>by_len</pre></td>
<td>Order by length of title.</td>
</tr>
<tr>
<td><pre>by_content</pre></td>
<td>Order by length of content.</td>
</tr>
<tr>
<td><pre>by_alpha</pre></td>
<td>Sort alphabetically.</td>
</tr>
<tr>
<td><pre>by_unread</pre></td>
<td>Order by read status.</td>
</tr>
<tr>
<td><pre>reverse_sort(sort)</pre></td>
<td>Reverse the given sort.</td>
</tr>
</table>

> **NOTE**: Sorts based on strings are done on unparsed strings. This means that
the strings could still have HTML built into them and untranslated entities.
This effects the sort because the length or the first character may not be
what's displayed. A title "&lt;strong&gt;Zoo&lt;/strong&gt;" will sort 
alphabetically before "Aardvark Sighting" because "<" is before "A", despite
the fact that the HTML will not be displayed.

> This was done to speed sorts so that interpretable HTML wouldn't have to be
stripped before and replaced after the sorting it done.

> **ALSO NOTE**: Sorts can possibly make Canto's memory footprint increase
marginally if they require access to data that isn't usually kept in memory.
Sorts that function on the title (`by_length`, `by_alpha`, etc.) have no effect
because the title is *always* in memory. Sorts like `by_date` require a date
field to be kept in memory so it adds a couple of bytes per story.

> This was also a speed tweak to avoid stories hitting the disk every time it's
sorted which makes the program grind to a halt.

The simplest way to use a sort is to do so when you define a tag

    :::python
    add_tag("Tag", sorts=[by_unread])

The above code will sort the given tag with unread stories first.

Similarly to filters and sorts you can set defaults and use keybinds to set
sorts.

    :::python
    default_tag_sorts([show_unread])
    keys['s'] = set_tag_sort(show_unread)

And, once again, like `default_tag_filters`, explicit tags inherit the tag
filters from the previous call to default_tag_sorts, while implicit tags
inherit the sorts from the final call to default_tag_sorts.

Sorts like `by_date` are most useful when combining two feeds into a single tag

    :::python
    add("http://news1", tags=["News"])
    add("http://news2", tags=["News"])
    add_tag("News", sorts=[by_date])


### Sort Order

Anywhere that a sort can be used, you can use multiple sorts with the
`sort_order` function from `canto.extra`. This takes any number of sorts in
order of priority.

    :::python
    default_tag_sorts([sort_order(by_unread, by_alpha)])

This snippet will make tags sort items first by unread status and then sort the
same items alphabetically.

</div>

## Hooks

<div class="section">

Canto includes a number of hooks for outside extensibility. You may find hooks
to be most useful when you author them yourself.  Even so, but `canto.extra` 
does include a few basic, but useful, hooks.

The possible hooks:

<table>
<tr>
<td><pre>start_hook</pre></td>
<td>Run once, on startup</td>
</tr>
<tr>
<td><pre>resize_hook</pre></td>
<td>Run when the window is resized (including on start)</td>
</tr>>
<tr>
<td><pre>new_hook</pre></td>
<td>Run once for every new item.</td>
</tr>>
<tr>
<td><pre>select_hook</pre></td>
<td>Run when a new item is selected</td>
</tr>
<tr>
<td><pre>unselect_hook</pre></td>
<td>Run when an item is unselected</td>
</tr>
<tr>
<td><pre>state_change_hook</pre></td>
<td>Run whenever an item's state (read/marked) changes</td>
</tr>
<tr>
<td><pre>update_hook</pre></td>
<td>Run when the interface updates</td>
</tr>
<tr>
<td><pre>end_hook</pre></td>
<td>Run when the interface closes</td>
</tr>
</table>

> **NOTE**: All hooks are enforced by the interface **except new_hook**.
`new_hook` is intended to be used as a notification method. All other hooks
don't function unless Canto is running.

### Using hooks

There are only two hooks included in `canto.extra` by default. These are for
manipulating the titles of an xterm (or another compatible X terminal).

    :::python
    select_hook = set_xterm_title
    end_hook = clear_xterm_title

This will set the xterm's title to "Tag - Title" when you select an item and
clear it when Canto closes.

Because this hook doesn't work everywhere and where it doesn't work it
essentially clobbers ncurses by printing to the screen (you set an xterm
title by writing to stdout with a special code), it's usually preferable to
check the environment's `TERM` before employing the hooks.

    :::python
    import os
    if os.getenv("TERM") == "xterm":  # Or other compatible term
        select_hook = set_xterm_title
        end_hook = clear_xterm_title

This code ensures that when you switch to the Linux console or another terminal,
Canto won't start spewing uninterpreted content to the screen.

</div>
